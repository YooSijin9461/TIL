TIL0608

## 1. 오늘 배운것

### 알고리즘



알고리즘 하루 한 문제

## 2. 문제 풀이

BOJ(2230) 수 고르기

N(1≤N≤100,000)개의 수로 이루어진 수열 A[1], A[2], …, A[N]이 있다. 이 수열에서 두 수를 골랐을 때(같은 수일 수도 있다), 그 차이가 M 이상이면서 제일 작은 경우를 구하는 프로그램을 작성하시오.

예를 들어 수열이 {1, 2, 3, 4, 5}라고 하자. 만약 M=3일 경우, 1 4, 1 5, 2 5를 골랐을 때 그 차이가 M 이상이 된다. 이 중에서 차이가 가장 작은 경우는 1 4나 2 5를 골랐을 때의 3이 된다.

``````python
N, M = map(int, input().split())
lst = [int(input()) for _ in range(N)]
lst.sort()
# 시작지점과 끝지점을 동일선상에 두고 비교하는 two-pointer 알고리즘을 이용했다.
start, end = 0, 0
res = 2000000001
while start < N and end < N:
    if lst[end] - lst[start] < M:
        end += 1
    else:
        res = min(res, lst[end] - lst[start])
        start += 1

print(res)
``````

어제 배운 Two-Pointer알고리즘을 더 명확히 이해하기 위해서 비슷한 유형의 문제를 풀어보았다. 시작지점과 끝지점을 반대편에 둔 어제의 문제와는 다르게, 오늘은 한쪽지점에서 같이시작하여 비교하고 문제를 풀이했다. 문제의 해결시간이 생각보다 오래나왔는데, 아마 res 값이 M과 같을경우 break문을 실행하는 것을 추가해준다면 더 줄일 것 이다.