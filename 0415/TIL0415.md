TIL0415

## 1. 오늘 배운것

### 알고리즘



알고리즘 하루 한 문제

## 2. 문제 풀이

SWEA(11760) 최소합

NxN 칸에 숫자가 적힌 판이 주어지고, 각 칸에서는 오른쪽이나 아래로만 이동할 수 있다.

맨 왼쪽 위에서 오른쪽 아래까지 이동할 때, 지나는 칸에 써진 숫자의 합계가 최소가 되도록 움직였다면 이때의 합계가 얼마인지 출력하는 프로그램을 만드시오.

첫 줄에 테스트케이스의 수 T가 주어진다. 1<=T<=50

다음 줄부터 테스트 케이스의 별로 첫 줄에 가로 세로 칸 수 N이 주어지고, 다음 줄부터 N개씩 N개의 줄에 걸쳐 10이하의 자연수가 주어진다. 3<=N<=13

``````python
T = int(input())
for tc in range(1, T+1):
    N = int(input())
    arr = [list(map(int, input().split())) for _ in range(N)]
    # 각 배열의 왼쪽 벽과 위쪽벽은 이동 방향이 1가지 밖에 없으므로 배열값과 함께 더해준다.
    for i in range(1, N):
        arr[i][0] += arr[i-1][0]
        arr[0][i] += arr[0][i-1]
    # 나머지 안쪽 부분은 2가지의 합 중 최소값을 반영하여 배열값과 함께 더해준다.
    for i in range(1, N):
        for j in range(1, N):
            arr[i][j] += min(arr[i-1][j], arr[i][j-1])
    # 도착 지점인 N-1, N-1 좌표의 값을 출력한다.
    print('#{} {}'.format(tc, arr[N-1][N-1]))
``````

기존에는 BFS나 DFS를 이용하여 풀었지만 이를 이용할 시 메모리 초과나 시간초과가 뜨는 경우가 많았다. (다양한 경우의 수를 재귀를 이용하여 풀기 때문에) 하지만 DP를 이용하여 풀어보니 시간도 확실히 절약되고 직관적으로 해결할 수 있게 되었다.