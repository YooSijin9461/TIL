TIL0830

## 1. 오늘 배운것



## Sort

순서가 없는 데이터들을 순서(오름차순, 내림차순)대로 나열하는 것

정렬 알고리즘은 시간 복잡도에 따라 성능을 좌우되며 성능이 좋을수록 그현 방법이 어렵습니다.



## 정렬의 종류

흔히 쓰이는 정렬 중 크게 5가지로 분류 해 보았습니다.

- 버블 정렬 (Bubble Sort)
- 선택 정렬 (Selection Sort)
- 삽입 정렬 (Insertion Sort)
- 병합 정렬 (Merge Sort)
- 퀵 정렬 (Quick Sort)



### 버블 정렬 (Bubble Sort)

앞이나 뒤에서부터 차례대로 인접한 두 수를 비교하며 정렬해나가는 알고리즘입니다.

일반적으로, O(N^2)의 시간복잡도를 가지고 있습니다.



### 선택 정렬 (Selection Sort)

주어진 데이터 중에 최소값을 찾고, 그 값을 맨 앞에 위치한 값과 교체합니다. 정렬된 수를 제외하고 앞의 과정을 반복합니다.

일반적으로, O(N^2)의 시간복잡도를 가지고 있습니다.



### 삽입 정렬 (Insertion Sort)

앞에서부터 차례대로 이미 정렬된 배열 부분과 비교하여, 자신의 위치를 찾아 삽입함으로써 정렬합니다.

일반적으로, O(N^2)의 시간복잡도를 가지고 있습니다. 버블 정렬이나 선택정렬에 비교하여 빠릅니다.



### 병합 정렬 (Merge Sort)

분할 정복 알고리즘 중의 하나입니다. 흔히 쓰이는 병합 정렬은 다음과 같이 작동합니다.

1. 리스트의 길이가 1 이하이면 이미 정렬된 것으로 봅니다. 그렇지 않은 경우에는
2. 분할(divide) : 정렬되지 않은 리스트를 절반으로 잘라 비슷한 크기의 두 부분 리스트로 나눕니다.
3. 정복(conquer) : 각 부분 리스트를 재귀적으로 병합 정렬을 이용해(두개의 리스트 중 제일 앞의 숫자가 작은 순으로 정렬) 정렬합니다.
4. 결합(combine) : 두 부분 리스트를 다시 하나의 정렬된 리스트로 병합 합니다. 이때 정렬 결과가 임시배열에 저장됩니다.
5. 복사(copy) : 임시 배열에 저장된 결과를 원래 배열에 복사합니다.

일반적으로, O(NlogN)의 시간복잡도를 가지고 있습니다.



### 퀵 정렬 (Quick Sort)

퀵 정렬 또한 분할 정복 알고리즘을 통해 데이터들을 정렬합니다.

1. 리스트 가운데서 하나의 원소를 고릅니다. 이렇게 고른 원소를 **피벗**이라고 한다.
2. 피벗 앞에는 피벗보다 값이 작은 모든 원소들이 오고, 피벗 뒤에는 피벗보다 값이 큰 모든 원소들이 오도록 피벗을 기준으로 리스트를 둘로 나눕니다. 이렇게 리스트를 둘로 나누는 것을 **분할**이라고 합니다. 분할을 마친 뒤에 피벗은 더 이상 움직이지 않습니다.
3. 분할된 두 개의 작은 리스트에 대해 재귀(Recursion)적으로 이 과정을 반복합니다. 재귀는 리스트의 크기가 0이나 1이 될 때까지 반복 됩니다.

일반적으로, O(NlogN)의 시간복잡도를 가지고 있습니다. 최악의 경우 O(N^2)의 시간 복잡도를 가집니다.

원소들 중에 같은 값이 있는 경우 같은 값들의 정렬 이후 순서가 초기 순서와 달라질 수 있어 불안정 정렬에 속합니다. 이러한 경우의 예시: 5-1, 5-2, 3, 2, 1 를 정렬하면 1, 2, 3, 5-2, 5-1 이 됩니다.