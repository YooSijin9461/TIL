TIL0219

## 1. 오늘 배운것

### 알고리즘

1. 오늘 알고리즘 풀이를 보는 중 zip라는 내장함수를 발견했다.
2. zip는 동일한 개수로 이루어진 자료형을 묶어주는 역할을 하는 함수이다.

``````python
Number = [1,2,3,4]
Name = ['hong','gil','dong','nim']
Number_Name = list(zip(Number,name))
print(Number_Name)
``````

``````
결과 : [(1 ,'hong'), (2 ,'gil'), (3 ,'dong'), (4 ,'nim')]
``````

위와 같이 Number와 Name가 동일한 개수(4)로 이루어진 것을 묵어준다.

보통 2차원 배열에서 행과 열의 위치를 바꾸고자 할 때 (전치행렬) 쉽고 간단하게 쓸 수 있다.



알고리즘 하루 한 문제

## 2. 문제 풀이

길이가 다른 쇠막대기가 겹치지 않게 쌓여있다. 그 위로 레이저가 관통하여 쇠막대기를 절단할 때, 잘린 쇠막대기의 개수를 구하여라. 단, 레이저는 쇠막대기의 끝부분을 절단하지 않는다.

`((()())())`와 같은 형태에서 `()`처럼 붙어있다면 레이저이고 그외의 괄호는 철이다.

``````python
# 총 테스트 케이스 수 입력
T = int(input())
for tc in range(1, T+1):
    # 철과 레이저의 상태를 입력받는다.
    steel = input()
    # 레이저를 '0'으로 바꿔준다.
    steel = list(steel.replace('()', '0'))
    # 중첩개수 변수 선언
    cnt = 0
    # 잘린 철으 개수 변수 선언
    sumst = 0
    for i in range(len(steel)):
        # 철의 첫부분이면 중첩 개수를 1개 늘려준다.
        if steel[i] == '(':
            cnt += 1
        # 철의 마지막 부분이면 중첩 개수를 1개 줄여 주고, 잘린 부분을 1개 추가해준다.
        elif steel[i] == ')':
            cnt -= 1
            sumst += 1
       # 레이저 부분이라면
        else:
            # 레이저 앞 부분중 중첩된 개수가 나올때 까지 찾고 그 중첩된 개수를 잘린 부분으로 추가해준다.
            for j in range(i-1, -1, -1):
                if steel[j] != '0':
                    sumst += cnt
                    break
    print('#{} {}'.format(tc, sumst))
``````



