TIL0302

## 1. 오늘 배운것

### 알고리즘

### 순열

- 몇 개를 골라 순서를 고려해 나열한 경우의 수를 말한다.
- 서로 다른 n 개 중 r 개를 골라 순서를 정해 나열하는 가짓수이며 순열이라는 의미의 영어 ‘Permutation’의 첫 글자 P를 따서 nPr로 표시한다.
- 예시로, n개의 카드가 있는데 카드 중 r장을 뽑아 나열하는 경우의 수를 순열로 표현할 수 있다.
- nPr의 계산식은 아래의 그림과 같이 쓸 수 있다.



![순열 본문 이미지 2](https://dbscthumb-phinf.pstatic.net/2765_000_71/20181114183131065_LRDG547ZG.gif/774784_1.gif?type=m1500&wm=N)

- 해당 원리와 식은 간단하지만 코드로 구현하는 것은 조금 어렵다.

``````python
# 예시 리스트
arr = [1, 2, 3]
N = len(arr)
# 결과들이 저장될 리스트
sel = [0] * N
# 해당 원소를 이미 사용했는지 안했는지에 대한 체크
check = [0] * N

def perm(idx):
    # 다 뽑아서 정리했다면
    if idx == N:
        print(sel)
    else:
        for i in range(N):
            if check[i] == 0:
                sel[idx] = arr[i] # 값을 써라
                check[i] = 1 # 사용을 했다는 표시
                perm(idx+1)
                check[i] = 0 # 다음 반복문을 위한 원상복구
# 순열 실행                
perm(0)
``````

순열을 재귀의 방법을 이용하여 표현하였다. 결과리스트와 체크리스트 2개의 리스트와 재귀를 이용하여 어렵게 느껴졌다. 그래서 이전에도 잠깐 배웠지만 이해가 안됐었다. 오늘 복습으로 이론적인 코드 부분을 이해 완료했다. 이후 문제를 풀어보면서 직접 원리를 적용시켜봐야 겠다.





알고리즘 하루 한 문제

## 2. 문제 풀이

10진수에서 제일 큰 숫자의 자리부터 일의 자리까지 숫자가 증가한다면 단조증가수이다. 수열을 입력할때, 수열의 부분 중 두 수의 곱(Ai*Aj)가 단조증가수라면, 그 수를 구하고 그 수가 여러개이면 최대값을 구하여라.

``````python
# 두수의 곱이 단조증가수인지 확인하는 함수 생성
def func(x, y):
    a = lst[x]*lst[y]
    # 임시값 지정
    temp = 10
    while a > 0:
        # 임시값보다 일의 자리수가 작다면 임시값을 일의 자리수로 변경
        if a%10 <= temp:
            temp = a%10
            # 기본값은 10으로 나눈 몫으로 변경
            a //= 10
        else:
            # 단조증가수가 아니라면 -1 반환
            return -1
    # 단조증가수라면 두 수의 곲 반환
    return lst[x]*lst[y]
# 테스트 케이스 입력
T = int(input())
for tc in range(1, T+1):
    # 수열의 길이 입력
    N = int(input())
    # 수열 입력
    lst = list(map(int, input().split()))
    # 단조증가수(임시) 생성
    mul = -1
    for i in range(N):
        for j in range(i+1, N):
            # 단조증가함수로 값을 비교하여 크다면 mul에 저장
            if func(i, j) > mul:
                mul = func(i, j)
    # 단조증가수 중 가장 큰 값으로 저장된 mul 출력(없다면 -1 기본값)
    print('#{} {}'.format(tc, mul))
``````



