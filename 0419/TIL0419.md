TIL0419

## 1. 오늘 배운것

### 알고리즘



알고리즘 하루 한 문제

## 2. 문제 풀이

SWEA(1265) 달란트2

초등학교 어린이를 대상으로 피아노 학원을 운영하는 김원장님은 5월 5일 어린이날을 맞이하여 학원에서 달란트 시장을 열기로 했다.

원장님은 매일 칭찬할 일이 있을 때마다 원생에게 1달란트 스티커를 나눠 주는데, 달란트 시장에서 1년 동안 모은 달란트만큼 사탕으로 교환해 주기로 했다.

여기에, 좀더 교육적 효과를 위하여 아이디어를 냈다.

10개의 달란트를 모은 원생에게 10개의 사탕을 나누어 주는 것이 아니라 10개를 3 묶음으로 나누어서 각 묶음의 곱의 개수로 사탕을 교환해 주기로 했다.

10 달란트를 3묶음으로 나눌 경우 어떻게 나누어야 가장 많은 사탕을 교환할 수 있을까?

예를 들어 1개, 1개, 8개 묶음으로 나누면 1x1x8=8 로 8개의 사탕과 교환할 수 있다.

최대는 3x3x4=36으로 36개의 사탕과 교환할 수 있다.

원생마다 달란트의 개수가 다르며 원장님은 서로 다른 묶음 개수를 제시하기로 했다.

달란트 수와 묶음의 수가 주어질 때 받을 수 있는 사탕의 최대 개수를 구하는 프로그램을 작성하시오.

``````python
T = int(input())
for tc in range(1, T+1):
    N, P = map(int, input().split())
    # 각 묶음마다 총 개수에서 묶음으로 나눈 몫을 가진 리스트 형태로 만들었다.
    lst = [N//P] * P
    # 나머지를 계산하여 나머지마다 1만큼 몫부분의 값을 추가했다.
    rest = N%P
    i = 0
    while rest:
        lst[i] += 1
        rest -= 1
        i += 1
    cnt = 1
    # 얻어진 리스트에서 값을 모두 곱하여 최대값을 구했다.
    for i in lst:
        cnt *= i
    print('#{} {}'.format(tc, cnt))

``````

 수학적인 지식으로 쉽게 풀었다고 생각했으나, 더 간단하고 직관적으로 풀 수 있는 방법이 있었다.

 그전에, 원래 테스트케이스를 `T = int(input())` 방식을 로  받았으나 `for tc in range(1, int(input())+1)`  형태로도 받을 수 있다는 걸 알았다.

이번 문제에서 전체적인 묶음에 대하여 하나하나 계산을 했지만, 나머지부분은 무조건 몫에서 +1이므로 `cnt = (N//P+1)**rest (N//P)*(P-rest) ` 형태의 간단한 수식으로 풀리는 것을 알게 되었다.