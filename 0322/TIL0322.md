TIL0322

## 1. 오늘 배운것

### 알고리즘



알고리즘 하루 한 문제

## 2. 문제 풀이

 "aabbaccc"의 경우 "2a2ba3c"(문자가 반복되지 않아 한번만 나타난 경우 1은 생략함)와 같이 표현할 수 있는데, 이러한 방식은 반복되는 문자가 적은 경우 압축률이 낮다는 단점이 있습니다. 예를 들면, "abcabcdede"와 같은 문자열은 전혀 압축되지 않습니다. "어피치"는 이러한 단점을 해결하기 위해 문자열을 1개 이상의 단위로 잘라서 압축하여 더 짧은 문자열로 표현할 수 있는지 방법을 찾아보려고 합니다.

 예를 들어, "ababcdcdababcdcd"의 경우 문자를 1개 단위로 자르면 전혀 압축되지 않지만, 2개 단위로 잘라서 압축한다면 "2ab2cd2ab2cd"로 표현할 수 있습니다. 다른 방법으로 8개 단위로 잘라서 압축한다면 "2ababcdcd"로 표현할 수 있으며, 이때가 가장 짧게 압축하여 표현할 수 있는 방법입니다.

 압축할 문자열 s가 매개변수로 주어질 때, 위에 설명한 방법으로 1개 이상 단위로 문자열을 잘라 압축하여 표현한 문자열 중 가장 짧은 것의 길이를 return 하도록 solution 함수를 완성해주세요.

``````python
def solution(s):
    # 각 문자열마다 단위로 자를때 길이의 개수를 구하는 리스트 생성
    check = [len(s)] * (len(s)//2 + 1)
    # 몇개로 자를지 단위 변수 생성
    num = 1
    # 절반 이상일 경우, 안자른 것과 같으므로
    while num < len(s)//2 + 1:
        res = ''
        temp = 1
        for i in range(0, len(s), num):
            # 단위 개수만큼 같은지 비교, 같다면 개수 추가
            if s[i:i+num] == s[i+num:i+(2*num)]:
                temp += 1
            else:
                # 다를때 같은 개수가 1개라면 단위만 입력
                if temp == 1:
                    res += s[i:i+num]
                else:
                    # 2개 이상이라면 숫자와 단어를 같이 합침
                    res += str(temp) + s[i:i+num]
                    temp = 1
        # 단위개수의 인덱스에 변환된 길이 입력
        check[num] = len(res)
        num += 1
    # 변환된 길이 중 최소값 반환
    return min(check)
``````



